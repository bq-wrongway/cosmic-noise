//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2::__framework_prelude::*;

use crate::*;

// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSFileAttributeKey = NSString;

// NS_TYPED_ENUM
#[cfg(feature = "NSString")]
pub type NSFileAttributeType = NSString;

// NS_TYPED_ENUM
#[cfg(feature = "NSString")]
pub type NSFileProtectionType = NSString;

// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSFileProviderServiceName = NSString;

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSVolumeEnumerationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSVolumeEnumerationOptions: NSUInteger {
        const NSVolumeEnumerationSkipHiddenVolumes = 1<<1;
        const NSVolumeEnumerationProduceFileReferenceURLs = 1<<2;
    }
}

unsafe impl Encode for NSVolumeEnumerationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSVolumeEnumerationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSDirectoryEnumerationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSDirectoryEnumerationOptions: NSUInteger {
        const NSDirectoryEnumerationSkipsSubdirectoryDescendants = 1<<0;
        const NSDirectoryEnumerationSkipsPackageDescendants = 1<<1;
        const NSDirectoryEnumerationSkipsHiddenFiles = 1<<2;
        const NSDirectoryEnumerationIncludesDirectoriesPostOrder = 1<<3;
        const NSDirectoryEnumerationProducesRelativePathURLs = 1<<4;
    }
}

unsafe impl Encode for NSDirectoryEnumerationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSDirectoryEnumerationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSFileManagerItemReplacementOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSFileManagerItemReplacementOptions: NSUInteger {
        const NSFileManagerItemReplacementUsingNewMetadataOnly = 1<<0;
        const NSFileManagerItemReplacementWithoutDeletingBackupItem = 1<<1;
    }
}

unsafe impl Encode for NSFileManagerItemReplacementOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFileManagerItemReplacementOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSURLRelationship(pub NSInteger);
impl NSURLRelationship {
    #[doc(alias = "NSURLRelationshipContains")]
    pub const Contains: Self = Self(0);
    #[doc(alias = "NSURLRelationshipSame")]
    pub const Same: Self = Self(1);
    #[doc(alias = "NSURLRelationshipOther")]
    pub const Other: Self = Self(2);
}

unsafe impl Encode for NSURLRelationship {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLRelationship {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSFileManagerUnmountOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSFileManagerUnmountOptions: NSUInteger {
        const NSFileManagerUnmountAllPartitionsAndEjectDisk = 1<<0;
        const NSFileManagerUnmountWithoutUI = 1<<1;
    }
}

unsafe impl Encode for NSFileManagerUnmountOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFileManagerUnmountOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileManagerUnmountDissentingProcessIdentifierErrorKey: &'static NSString;
}

extern "C" {
    #[cfg(all(feature = "NSNotification", feature = "NSString"))]
    pub static NSUbiquityIdentityDidChangeNotification: &'static NSNotificationName;
}

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSFileManager;

    unsafe impl ClassType for NSFileManager {
        type Super = NSObject;
        type Mutability = InteriorMutable;
    }
);

unsafe impl NSObjectProtocol for NSFileManager {}

extern_methods!(
    unsafe impl NSFileManager {
        #[method_id(@__retain_semantics Other defaultManager)]
        pub unsafe fn defaultManager() -> Retained<NSFileManager>;

        #[cfg(all(feature = "NSArray", feature = "NSString", feature = "NSURL"))]
        #[method_id(@__retain_semantics Other mountedVolumeURLsIncludingResourceValuesForKeys:options:)]
        pub unsafe fn mountedVolumeURLsIncludingResourceValuesForKeys_options(
            &self,
            property_keys: Option<&NSArray<NSURLResourceKey>>,
            options: NSVolumeEnumerationOptions,
        ) -> Option<Retained<NSArray<NSURL>>>;

        #[cfg(all(feature = "NSError", feature = "NSURL", feature = "block2"))]
        #[method(unmountVolumeAtURL:options:completionHandler:)]
        pub unsafe fn unmountVolumeAtURL_options_completionHandler(
            &self,
            url: &NSURL,
            mask: NSFileManagerUnmountOptions,
            completion_handler: &block2::Block<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(
            feature = "NSArray",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL"
        ))]
        #[method_id(@__retain_semantics Other contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:_)]
        pub unsafe fn contentsOfDirectoryAtURL_includingPropertiesForKeys_options_error(
            &self,
            url: &NSURL,
            keys: Option<&NSArray<NSURLResourceKey>>,
            mask: NSDirectoryEnumerationOptions,
        ) -> Result<Retained<NSArray<NSURL>>, Retained<NSError>>;

        #[cfg(all(feature = "NSArray", feature = "NSPathUtilities", feature = "NSURL"))]
        #[method_id(@__retain_semantics Other URLsForDirectory:inDomains:)]
        pub unsafe fn URLsForDirectory_inDomains(
            &self,
            directory: NSSearchPathDirectory,
            domain_mask: NSSearchPathDomainMask,
        ) -> Retained<NSArray<NSURL>>;

        #[cfg(all(feature = "NSError", feature = "NSPathUtilities", feature = "NSURL"))]
        #[method_id(@__retain_semantics Other URLForDirectory:inDomain:appropriateForURL:create:error:_)]
        pub unsafe fn URLForDirectory_inDomain_appropriateForURL_create_error(
            &self,
            directory: NSSearchPathDirectory,
            domain: NSSearchPathDomainMask,
            url: Option<&NSURL>,
            should_create: bool,
        ) -> Result<Retained<NSURL>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(getRelationship:ofDirectoryAtURL:toItemAtURL:error:_)]
        pub unsafe fn getRelationship_ofDirectoryAtURL_toItemAtURL_error(
            &self,
            out_relationship: NonNull<NSURLRelationship>,
            directory_url: &NSURL,
            other_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSPathUtilities", feature = "NSURL"))]
        #[method(getRelationship:ofDirectory:inDomain:toItemAtURL:error:_)]
        pub unsafe fn getRelationship_ofDirectory_inDomain_toItemAtURL_error(
            &self,
            out_relationship: NonNull<NSURLRelationship>,
            directory: NSSearchPathDirectory,
            domain_mask: NSSearchPathDomainMask,
            url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL"
        ))]
        #[method(createDirectoryAtURL:withIntermediateDirectories:attributes:error:_)]
        pub unsafe fn createDirectoryAtURL_withIntermediateDirectories_attributes_error(
            &self,
            url: &NSURL,
            create_intermediates: bool,
            attributes: Option<&NSDictionary<NSFileAttributeKey, AnyObject>>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(createSymbolicLinkAtURL:withDestinationURL:error:_)]
        pub unsafe fn createSymbolicLinkAtURL_withDestinationURL_error(
            &self,
            url: &NSURL,
            dest_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSFileManagerDelegate>>>;

        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSFileManagerDelegate>>,
        );

        #[cfg(all(feature = "NSDictionary", feature = "NSError", feature = "NSString"))]
        #[method(setAttributes:ofItemAtPath:error:_)]
        pub unsafe fn setAttributes_ofItemAtPath_error(
            &self,
            attributes: &NSDictionary<NSFileAttributeKey, AnyObject>,
            path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSError", feature = "NSString"))]
        #[method(createDirectoryAtPath:withIntermediateDirectories:attributes:error:_)]
        pub unsafe fn createDirectoryAtPath_withIntermediateDirectories_attributes_error(
            &self,
            path: &NSString,
            create_intermediates: bool,
            attributes: Option<&NSDictionary<NSFileAttributeKey, AnyObject>>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSArray", feature = "NSError", feature = "NSString"))]
        #[method_id(@__retain_semantics Other contentsOfDirectoryAtPath:error:_)]
        pub unsafe fn contentsOfDirectoryAtPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSArray<NSString>>, Retained<NSError>>;

        #[cfg(all(feature = "NSArray", feature = "NSError", feature = "NSString"))]
        #[method_id(@__retain_semantics Other subpathsOfDirectoryAtPath:error:_)]
        pub unsafe fn subpathsOfDirectoryAtPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSArray<NSString>>, Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSError", feature = "NSString"))]
        #[method_id(@__retain_semantics Other attributesOfItemAtPath:error:_)]
        pub unsafe fn attributesOfItemAtPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSDictionary<NSFileAttributeKey, AnyObject>>, Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSError", feature = "NSString"))]
        #[method_id(@__retain_semantics Other attributesOfFileSystemForPath:error:_)]
        pub unsafe fn attributesOfFileSystemForPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSDictionary<NSFileAttributeKey, AnyObject>>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[method(createSymbolicLinkAtPath:withDestinationPath:error:_)]
        pub unsafe fn createSymbolicLinkAtPath_withDestinationPath_error(
            &self,
            path: &NSString,
            dest_path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[method_id(@__retain_semantics Other destinationOfSymbolicLinkAtPath:error:_)]
        pub unsafe fn destinationOfSymbolicLinkAtPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSString>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[method(copyItemAtPath:toPath:error:_)]
        pub unsafe fn copyItemAtPath_toPath_error(
            &self,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[method(moveItemAtPath:toPath:error:_)]
        pub unsafe fn moveItemAtPath_toPath_error(
            &self,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[method(linkItemAtPath:toPath:error:_)]
        pub unsafe fn linkItemAtPath_toPath_error(
            &self,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[method(removeItemAtPath:error:_)]
        pub unsafe fn removeItemAtPath_error(
            &self,
            path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(copyItemAtURL:toURL:error:_)]
        pub unsafe fn copyItemAtURL_toURL_error(
            &self,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(moveItemAtURL:toURL:error:_)]
        pub unsafe fn moveItemAtURL_toURL_error(
            &self,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(linkItemAtURL:toURL:error:_)]
        pub unsafe fn linkItemAtURL_toURL_error(
            &self,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(removeItemAtURL:error:_)]
        pub unsafe fn removeItemAtURL_error(&self, url: &NSURL) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(trashItemAtURL:resultingItemURL:error:_)]
        pub unsafe fn trashItemAtURL_resultingItemURL_error(
            &self,
            url: &NSURL,
            out_resulting_url: Option<&mut Option<Retained<NSURL>>>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[deprecated = "Use -attributesOfItemAtPath:error: instead"]
        #[method_id(@__retain_semantics Other fileAttributesAtPath:traverseLink:)]
        pub unsafe fn fileAttributesAtPath_traverseLink(
            &self,
            path: &NSString,
            yorn: bool,
        ) -> Option<Retained<NSDictionary>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[deprecated = "Use -setAttributes:ofItemAtPath:error: instead"]
        #[method(changeFileAttributes:atPath:)]
        pub unsafe fn changeFileAttributes_atPath(
            &self,
            attributes: &NSDictionary,
            path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[deprecated = "Use -contentsOfDirectoryAtPath:error: instead"]
        #[method_id(@__retain_semantics Other directoryContentsAtPath:)]
        pub unsafe fn directoryContentsAtPath(&self, path: &NSString) -> Option<Retained<NSArray>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[deprecated = "Use -attributesOfFileSystemForPath:error: instead"]
        #[method_id(@__retain_semantics Other fileSystemAttributesAtPath:)]
        pub unsafe fn fileSystemAttributesAtPath(
            &self,
            path: &NSString,
        ) -> Option<Retained<NSDictionary>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -destinationOfSymbolicLinkAtPath:error:"]
        #[method_id(@__retain_semantics Other pathContentOfSymbolicLinkAtPath:)]
        pub unsafe fn pathContentOfSymbolicLinkAtPath(
            &self,
            path: &NSString,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -createSymbolicLinkAtPath:error: instead"]
        #[method(createSymbolicLinkAtPath:pathContent:)]
        pub unsafe fn createSymbolicLinkAtPath_pathContent(
            &self,
            path: &NSString,
            otherpath: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[deprecated = "Use -createDirectoryAtPath:withIntermediateDirectories:attributes:error: instead"]
        #[method(createDirectoryAtPath:attributes:)]
        pub unsafe fn createDirectoryAtPath_attributes(
            &self,
            path: &NSString,
            attributes: &NSDictionary,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[deprecated = "Not supported"]
        #[method(linkPath:toPath:handler:)]
        pub unsafe fn linkPath_toPath_handler(
            &self,
            src: &NSString,
            dest: &NSString,
            handler: Option<&AnyObject>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[deprecated = "Not supported"]
        #[method(copyPath:toPath:handler:)]
        pub unsafe fn copyPath_toPath_handler(
            &self,
            src: &NSString,
            dest: &NSString,
            handler: Option<&AnyObject>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[deprecated = "Not supported"]
        #[method(movePath:toPath:handler:)]
        pub unsafe fn movePath_toPath_handler(
            &self,
            src: &NSString,
            dest: &NSString,
            handler: Option<&AnyObject>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[deprecated = "Not supported"]
        #[method(removeFileAtPath:handler:)]
        pub unsafe fn removeFileAtPath_handler(
            &self,
            path: &NSString,
            handler: Option<&AnyObject>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other currentDirectoryPath)]
        pub unsafe fn currentDirectoryPath(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[method(changeCurrentDirectoryPath:)]
        pub unsafe fn changeCurrentDirectoryPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[method(fileExistsAtPath:)]
        pub unsafe fn fileExistsAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[method(fileExistsAtPath:isDirectory:)]
        pub unsafe fn fileExistsAtPath_isDirectory(
            &self,
            path: &NSString,
            is_directory: *mut Bool,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[method(isReadableFileAtPath:)]
        pub unsafe fn isReadableFileAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[method(isWritableFileAtPath:)]
        pub unsafe fn isWritableFileAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[method(isExecutableFileAtPath:)]
        pub unsafe fn isExecutableFileAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[method(isDeletableFileAtPath:)]
        pub unsafe fn isDeletableFileAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[method(contentsEqualAtPath:andPath:)]
        pub unsafe fn contentsEqualAtPath_andPath(
            &self,
            path1: &NSString,
            path2: &NSString,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other displayNameAtPath:)]
        pub unsafe fn displayNameAtPath(&self, path: &NSString) -> Retained<NSString>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[method_id(@__retain_semantics Other componentsToDisplayForPath:)]
        pub unsafe fn componentsToDisplayForPath(
            &self,
            path: &NSString,
        ) -> Option<Retained<NSArray<NSString>>>;

        #[cfg(all(feature = "NSEnumerator", feature = "NSString"))]
        #[method_id(@__retain_semantics Other enumeratorAtPath:)]
        pub unsafe fn enumeratorAtPath(
            &self,
            path: &NSString,
        ) -> Option<Retained<NSDirectoryEnumerator<NSString>>>;

        #[cfg(all(
            feature = "NSArray",
            feature = "NSEnumerator",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL",
            feature = "block2"
        ))]
        #[method_id(@__retain_semantics Other enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:)]
        pub unsafe fn enumeratorAtURL_includingPropertiesForKeys_options_errorHandler(
            &self,
            url: &NSURL,
            keys: Option<&NSArray<NSURLResourceKey>>,
            mask: NSDirectoryEnumerationOptions,
            handler: Option<&block2::Block<dyn Fn(NonNull<NSURL>, NonNull<NSError>) -> Bool>>,
        ) -> Option<Retained<NSDirectoryEnumerator<NSURL>>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[method_id(@__retain_semantics Other subpathsAtPath:)]
        pub unsafe fn subpathsAtPath(&self, path: &NSString)
            -> Option<Retained<NSArray<NSString>>>;

        #[cfg(all(feature = "NSData", feature = "NSString"))]
        #[method_id(@__retain_semantics Other contentsAtPath:)]
        pub unsafe fn contentsAtPath(&self, path: &NSString) -> Option<Retained<NSData>>;

        #[cfg(all(feature = "NSData", feature = "NSDictionary", feature = "NSString"))]
        #[method(createFileAtPath:contents:attributes:)]
        pub unsafe fn createFileAtPath_contents_attributes(
            &self,
            path: &NSString,
            data: Option<&NSData>,
            attr: Option<&NSDictionary<NSFileAttributeKey, AnyObject>>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[method(fileSystemRepresentationWithPath:)]
        pub unsafe fn fileSystemRepresentationWithPath(&self, path: &NSString) -> NonNull<c_char>;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other stringWithFileSystemRepresentation:length:)]
        pub unsafe fn stringWithFileSystemRepresentation_length(
            &self,
            str: NonNull<c_char>,
            len: NSUInteger,
        ) -> Retained<NSString>;

        #[cfg(all(feature = "NSError", feature = "NSString", feature = "NSURL"))]
        #[method(replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:_)]
        pub unsafe fn replaceItemAtURL_withItemAtURL_backupItemName_options_resultingItemURL_error(
            &self,
            original_item_url: &NSURL,
            new_item_url: &NSURL,
            backup_item_name: Option<&NSString>,
            options: NSFileManagerItemReplacementOptions,
            resulting_url: Option<&mut Option<Retained<NSURL>>>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(setUbiquitous:itemAtURL:destinationURL:error:_)]
        pub unsafe fn setUbiquitous_itemAtURL_destinationURL_error(
            &self,
            flag: bool,
            url: &NSURL,
            destination_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSURL")]
        #[method(isUbiquitousItemAtURL:)]
        pub unsafe fn isUbiquitousItemAtURL(&self, url: &NSURL) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(startDownloadingUbiquitousItemAtURL:error:_)]
        pub unsafe fn startDownloadingUbiquitousItemAtURL_error(
            &self,
            url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[method(evictUbiquitousItemAtURL:error:_)]
        pub unsafe fn evictUbiquitousItemAtURL_error(
            &self,
            url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[method_id(@__retain_semantics Other URLForUbiquityContainerIdentifier:)]
        pub unsafe fn URLForUbiquityContainerIdentifier(
            &self,
            container_identifier: Option<&NSString>,
        ) -> Option<Retained<NSURL>>;

        #[cfg(all(feature = "NSDate", feature = "NSError", feature = "NSURL"))]
        #[method_id(@__retain_semantics Other URLForPublishingUbiquitousItemAtURL:expirationDate:error:_)]
        pub unsafe fn URLForPublishingUbiquitousItemAtURL_expirationDate_error(
            &self,
            url: &NSURL,
            out_date: Option<&mut Option<Retained<NSDate>>>,
        ) -> Result<Retained<NSURL>, Retained<NSError>>;

        #[cfg(feature = "NSObject")]
        #[method_id(@__retain_semantics Other ubiquityIdentityToken)]
        pub unsafe fn ubiquityIdentityToken(&self) -> Option<Retained<TodoProtocols>>;

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL",
            feature = "block2"
        ))]
        #[method(getFileProviderServicesForItemAtURL:completionHandler:)]
        pub unsafe fn getFileProviderServicesForItemAtURL_completionHandler(
            &self,
            url: &NSURL,
            completion_handler: &block2::Block<
                dyn Fn(
                    *mut NSDictionary<NSFileProviderServiceName, NSFileProviderService>,
                    *mut NSError,
                ),
            >,
        );

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[method_id(@__retain_semantics Other containerURLForSecurityApplicationGroupIdentifier:)]
        pub unsafe fn containerURLForSecurityApplicationGroupIdentifier(
            &self,
            group_identifier: &NSString,
        ) -> Option<Retained<NSURL>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSFileManager {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_methods!(
    /// NSUserInformation
    unsafe impl NSFileManager {
        #[cfg(feature = "NSURL")]
        #[method_id(@__retain_semantics Other homeDirectoryForCurrentUser)]
        pub unsafe fn homeDirectoryForCurrentUser(&self) -> Retained<NSURL>;

        #[cfg(feature = "NSURL")]
        #[method_id(@__retain_semantics Other temporaryDirectory)]
        pub unsafe fn temporaryDirectory(&self) -> Retained<NSURL>;

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[method_id(@__retain_semantics Other homeDirectoryForUser:)]
        pub unsafe fn homeDirectoryForUser(&self, user_name: &NSString) -> Option<Retained<NSURL>>;
    }
);

extern_protocol!(
    pub unsafe trait NSFileManagerDelegate: NSObjectProtocol {
        #[cfg(feature = "NSString")]
        #[optional]
        #[method(fileManager:shouldCopyItemAtPath:toPath:)]
        unsafe fn fileManager_shouldCopyItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(feature = "NSURL")]
        #[optional]
        #[method(fileManager:shouldCopyItemAtURL:toURL:)]
        unsafe fn fileManager_shouldCopyItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[optional]
        #[method(fileManager:shouldProceedAfterError:copyingItemAtPath:toPath:)]
        unsafe fn fileManager_shouldProceedAfterError_copyingItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[optional]
        #[method(fileManager:shouldProceedAfterError:copyingItemAtURL:toURL:)]
        unsafe fn fileManager_shouldProceedAfterError_copyingItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[optional]
        #[method(fileManager:shouldMoveItemAtPath:toPath:)]
        unsafe fn fileManager_shouldMoveItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(feature = "NSURL")]
        #[optional]
        #[method(fileManager:shouldMoveItemAtURL:toURL:)]
        unsafe fn fileManager_shouldMoveItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[optional]
        #[method(fileManager:shouldProceedAfterError:movingItemAtPath:toPath:)]
        unsafe fn fileManager_shouldProceedAfterError_movingItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[optional]
        #[method(fileManager:shouldProceedAfterError:movingItemAtURL:toURL:)]
        unsafe fn fileManager_shouldProceedAfterError_movingItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[optional]
        #[method(fileManager:shouldLinkItemAtPath:toPath:)]
        unsafe fn fileManager_shouldLinkItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(feature = "NSURL")]
        #[optional]
        #[method(fileManager:shouldLinkItemAtURL:toURL:)]
        unsafe fn fileManager_shouldLinkItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[optional]
        #[method(fileManager:shouldProceedAfterError:linkingItemAtPath:toPath:)]
        unsafe fn fileManager_shouldProceedAfterError_linkingItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[optional]
        #[method(fileManager:shouldProceedAfterError:linkingItemAtURL:toURL:)]
        unsafe fn fileManager_shouldProceedAfterError_linkingItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[optional]
        #[method(fileManager:shouldRemoveItemAtPath:)]
        unsafe fn fileManager_shouldRemoveItemAtPath(
            &self,
            file_manager: &NSFileManager,
            path: &NSString,
        ) -> bool;

        #[cfg(feature = "NSURL")]
        #[optional]
        #[method(fileManager:shouldRemoveItemAtURL:)]
        unsafe fn fileManager_shouldRemoveItemAtURL(
            &self,
            file_manager: &NSFileManager,
            url: &NSURL,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[optional]
        #[method(fileManager:shouldProceedAfterError:removingItemAtPath:)]
        unsafe fn fileManager_shouldProceedAfterError_removingItemAtPath(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[optional]
        #[method(fileManager:shouldProceedAfterError:removingItemAtURL:)]
        unsafe fn fileManager_shouldProceedAfterError_removingItemAtURL(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            url: &NSURL,
        ) -> bool;
    }

    unsafe impl ProtocolType for dyn NSFileManagerDelegate {}
);

__inner_extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSEnumerator")]
    pub struct NSDirectoryEnumerator<ObjectType: ?Sized = AnyObject> {
        __superclass: NSEnumerator<ObjectType>,
        _inner0: PhantomData<*mut ObjectType>,
        notunwindsafe: PhantomData<&'static mut ()>,
    }

    #[cfg(feature = "NSEnumerator")]
    unsafe impl<ObjectType: ?Sized + Message> ClassType for NSDirectoryEnumerator<ObjectType> {
        #[inherits(NSObject)]
        type Super = NSEnumerator<ObjectType>;
        type Mutability = Mutable;

        fn as_super(&self) -> &Self::Super {
            &self.__superclass
        }

        fn as_super_mut(&mut self) -> &mut Self::Super {
            &mut self.__superclass
        }
    }
);

#[cfg(feature = "NSEnumerator")]
unsafe impl<ObjectType: ?Sized> NSFastEnumeration for NSDirectoryEnumerator<ObjectType> {}

#[cfg(feature = "NSEnumerator")]
unsafe impl<ObjectType: ?Sized> NSObjectProtocol for NSDirectoryEnumerator<ObjectType> {}

extern_methods!(
    #[cfg(feature = "NSEnumerator")]
    unsafe impl<ObjectType: Message> NSDirectoryEnumerator<ObjectType> {
        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[method_id(@__retain_semantics Other fileAttributes)]
        pub unsafe fn fileAttributes(
            &self,
        ) -> Option<Retained<NSDictionary<NSFileAttributeKey, AnyObject>>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[method_id(@__retain_semantics Other directoryAttributes)]
        pub unsafe fn directoryAttributes(
            &self,
        ) -> Option<Retained<NSDictionary<NSFileAttributeKey, AnyObject>>>;

        #[method(isEnumeratingDirectoryPostOrder)]
        pub unsafe fn isEnumeratingDirectoryPostOrder(&self) -> bool;

        #[method(skipDescendents)]
        pub unsafe fn skipDescendents(&mut self);

        #[method(level)]
        pub unsafe fn level(&self) -> NSUInteger;

        #[method(skipDescendants)]
        pub unsafe fn skipDescendants(&mut self);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(feature = "NSEnumerator")]
    unsafe impl<ObjectType: Message> NSDirectoryEnumerator<ObjectType> {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSFileProviderService;

    unsafe impl ClassType for NSFileProviderService {
        type Super = NSObject;
        type Mutability = InteriorMutable;
    }
);

unsafe impl NSObjectProtocol for NSFileProviderService {}

extern_methods!(
    unsafe impl NSFileProviderService {
        #[cfg(all(feature = "NSError", feature = "NSXPCConnection", feature = "block2"))]
        #[method(getFileProviderConnectionWithCompletionHandler:)]
        pub unsafe fn getFileProviderConnectionWithCompletionHandler(
            &self,
            completion_handler: &block2::Block<dyn Fn(*mut NSXPCConnection, *mut NSError)>,
        );

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other name)]
        pub unsafe fn name(&self) -> Retained<NSFileProviderServiceName>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSFileProviderService {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileType: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileTypeDirectory: &'static NSFileAttributeType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileTypeRegular: &'static NSFileAttributeType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileTypeSymbolicLink: &'static NSFileAttributeType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileTypeSocket: &'static NSFileAttributeType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileTypeCharacterSpecial: &'static NSFileAttributeType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileTypeBlockSpecial: &'static NSFileAttributeType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileTypeUnknown: &'static NSFileAttributeType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileSize: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileModificationDate: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileReferenceCount: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileDeviceIdentifier: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileOwnerAccountName: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileGroupOwnerAccountName: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFilePosixPermissions: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileSystemNumber: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileSystemFileNumber: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileExtensionHidden: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileHFSCreatorCode: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileHFSTypeCode: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileImmutable: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileAppendOnly: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileCreationDate: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileOwnerAccountID: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileGroupOwnerAccountID: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileBusy: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionKey: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionNone: &'static NSFileProtectionType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionComplete: &'static NSFileProtectionType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionCompleteUnlessOpen: &'static NSFileProtectionType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionCompleteUntilFirstUserAuthentication: &'static NSFileProtectionType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionCompleteWhenUserInactive: &'static NSFileProtectionType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileSystemSize: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileSystemFreeSize: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileSystemNodes: &'static NSFileAttributeKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileSystemFreeNodes: &'static NSFileAttributeKey;
}

extern_methods!(
    /// NSFileAttributes
    #[cfg(feature = "NSDictionary")]
    unsafe impl<KeyType: Message, ObjectType: Message> NSDictionary<KeyType, ObjectType> {
        #[method(fileSize)]
        pub unsafe fn fileSize(&self) -> c_ulonglong;

        #[cfg(feature = "NSDate")]
        #[method_id(@__retain_semantics Other fileModificationDate)]
        pub unsafe fn fileModificationDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other fileType)]
        pub unsafe fn fileType(&self) -> Option<Retained<NSString>>;

        #[method(filePosixPermissions)]
        pub unsafe fn filePosixPermissions(&self) -> NSUInteger;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other fileOwnerAccountName)]
        pub unsafe fn fileOwnerAccountName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other fileGroupOwnerAccountName)]
        pub unsafe fn fileGroupOwnerAccountName(&self) -> Option<Retained<NSString>>;

        #[method(fileSystemNumber)]
        pub unsafe fn fileSystemNumber(&self) -> NSInteger;

        #[method(fileSystemFileNumber)]
        pub unsafe fn fileSystemFileNumber(&self) -> NSUInteger;

        #[method(fileExtensionHidden)]
        pub unsafe fn fileExtensionHidden(&self) -> bool;

        #[method(fileHFSCreatorCode)]
        pub unsafe fn fileHFSCreatorCode(&self) -> OSType;

        #[method(fileHFSTypeCode)]
        pub unsafe fn fileHFSTypeCode(&self) -> OSType;

        #[method(fileIsImmutable)]
        pub unsafe fn fileIsImmutable(&self) -> bool;

        #[method(fileIsAppendOnly)]
        pub unsafe fn fileIsAppendOnly(&self) -> bool;

        #[cfg(feature = "NSDate")]
        #[method_id(@__retain_semantics Other fileCreationDate)]
        pub unsafe fn fileCreationDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSValue")]
        #[method_id(@__retain_semantics Other fileOwnerAccountID)]
        pub unsafe fn fileOwnerAccountID(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "NSValue")]
        #[method_id(@__retain_semantics Other fileGroupOwnerAccountID)]
        pub unsafe fn fileGroupOwnerAccountID(&self) -> Option<Retained<NSNumber>>;
    }
);
