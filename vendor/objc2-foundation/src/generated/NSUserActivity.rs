//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2::__framework_prelude::*;

use crate::*;

#[cfg(feature = "NSString")]
pub type NSUserActivityPersistentIdentifier = NSString;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSUserActivity;

    unsafe impl ClassType for NSUserActivity {
        type Super = NSObject;
        type Mutability = InteriorMutable;
    }
);

unsafe impl NSObjectProtocol for NSUserActivity {}

extern_methods!(
    unsafe impl NSUserActivity {
        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Init initWithActivityType:)]
        pub unsafe fn initWithActivityType(
            this: Allocated<Self>,
            activity_type: &NSString,
        ) -> Retained<Self>;

        #[deprecated = "Use initWithActivityType: with a specific activity type string"]
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other activityType)]
        pub unsafe fn activityType(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other title)]
        pub unsafe fn title(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[method(setTitle:)]
        pub unsafe fn setTitle(&self, title: Option<&NSString>);

        #[cfg(feature = "NSDictionary")]
        #[method_id(@__retain_semantics Other userInfo)]
        pub unsafe fn userInfo(&self) -> Option<Retained<NSDictionary>>;

        #[cfg(feature = "NSDictionary")]
        #[method(setUserInfo:)]
        pub unsafe fn setUserInfo(&self, user_info: Option<&NSDictionary>);

        #[cfg(feature = "NSDictionary")]
        #[method(addUserInfoEntriesFromDictionary:)]
        pub unsafe fn addUserInfoEntriesFromDictionary(&self, other_dictionary: &NSDictionary);

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[method_id(@__retain_semantics Other requiredUserInfoKeys)]
        pub unsafe fn requiredUserInfoKeys(&self) -> Option<Retained<NSSet<NSString>>>;

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[method(setRequiredUserInfoKeys:)]
        pub unsafe fn setRequiredUserInfoKeys(
            &self,
            required_user_info_keys: Option<&NSSet<NSString>>,
        );

        #[method(needsSave)]
        pub unsafe fn needsSave(&self) -> bool;

        #[method(setNeedsSave:)]
        pub unsafe fn setNeedsSave(&self, needs_save: bool);

        #[cfg(feature = "NSURL")]
        #[method_id(@__retain_semantics Other webpageURL)]
        pub unsafe fn webpageURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[method(setWebpageURL:)]
        pub unsafe fn setWebpageURL(&self, webpage_url: Option<&NSURL>);

        #[cfg(feature = "NSURL")]
        #[method_id(@__retain_semantics Other referrerURL)]
        pub unsafe fn referrerURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[method(setReferrerURL:)]
        pub unsafe fn setReferrerURL(&self, referrer_url: Option<&NSURL>);

        #[cfg(feature = "NSDate")]
        #[method_id(@__retain_semantics Other expirationDate)]
        pub unsafe fn expirationDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[method(setExpirationDate:)]
        pub unsafe fn setExpirationDate(&self, expiration_date: Option<&NSDate>);

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[method_id(@__retain_semantics Other keywords)]
        pub unsafe fn keywords(&self) -> Retained<NSSet<NSString>>;

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[method(setKeywords:)]
        pub unsafe fn setKeywords(&self, keywords: &NSSet<NSString>);

        #[method(supportsContinuationStreams)]
        pub unsafe fn supportsContinuationStreams(&self) -> bool;

        #[method(setSupportsContinuationStreams:)]
        pub unsafe fn setSupportsContinuationStreams(&self, supports_continuation_streams: bool);

        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSUserActivityDelegate>>>;

        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSUserActivityDelegate>>,
        );

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other targetContentIdentifier)]
        pub unsafe fn targetContentIdentifier(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[method(setTargetContentIdentifier:)]
        pub unsafe fn setTargetContentIdentifier(
            &self,
            target_content_identifier: Option<&NSString>,
        );

        #[method(becomeCurrent)]
        pub unsafe fn becomeCurrent(&self);

        #[method(resignCurrent)]
        pub unsafe fn resignCurrent(&self);

        #[method(invalidate)]
        pub unsafe fn invalidate(&self);

        #[cfg(all(feature = "NSError", feature = "NSStream", feature = "block2"))]
        #[method(getContinuationStreamsWithCompletionHandler:)]
        pub unsafe fn getContinuationStreamsWithCompletionHandler(
            &self,
            completion_handler: &block2::Block<
                dyn Fn(*mut NSInputStream, *mut NSOutputStream, *mut NSError),
            >,
        );

        #[method(isEligibleForHandoff)]
        pub unsafe fn isEligibleForHandoff(&self) -> bool;

        #[method(setEligibleForHandoff:)]
        pub unsafe fn setEligibleForHandoff(&self, eligible_for_handoff: bool);

        #[method(isEligibleForSearch)]
        pub unsafe fn isEligibleForSearch(&self) -> bool;

        #[method(setEligibleForSearch:)]
        pub unsafe fn setEligibleForSearch(&self, eligible_for_search: bool);

        #[method(isEligibleForPublicIndexing)]
        pub unsafe fn isEligibleForPublicIndexing(&self) -> bool;

        #[method(setEligibleForPublicIndexing:)]
        pub unsafe fn setEligibleForPublicIndexing(&self, eligible_for_public_indexing: bool);

        #[method(isEligibleForPrediction)]
        pub unsafe fn isEligibleForPrediction(&self) -> bool;

        #[method(setEligibleForPrediction:)]
        pub unsafe fn setEligibleForPrediction(&self, eligible_for_prediction: bool);

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other persistentIdentifier)]
        pub unsafe fn persistentIdentifier(
            &self,
        ) -> Option<Retained<NSUserActivityPersistentIdentifier>>;

        #[cfg(feature = "NSString")]
        #[method(setPersistentIdentifier:)]
        pub unsafe fn setPersistentIdentifier(
            &self,
            persistent_identifier: Option<&NSUserActivityPersistentIdentifier>,
        );

        #[cfg(all(feature = "NSArray", feature = "NSString", feature = "block2"))]
        #[method(deleteSavedUserActivitiesWithPersistentIdentifiers:completionHandler:)]
        pub unsafe fn deleteSavedUserActivitiesWithPersistentIdentifiers_completionHandler(
            persistent_identifiers: &NSArray<NSUserActivityPersistentIdentifier>,
            handler: &block2::Block<dyn Fn()>,
        );

        #[cfg(feature = "block2")]
        #[method(deleteAllSavedUserActivitiesWithCompletionHandler:)]
        pub unsafe fn deleteAllSavedUserActivitiesWithCompletionHandler(
            handler: &block2::Block<dyn Fn()>,
        );
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSUserActivity {
        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSUserActivityTypeBrowsingWeb: &'static NSString;
}

extern_protocol!(
    pub unsafe trait NSUserActivityDelegate: NSObjectProtocol {
        #[optional]
        #[method(userActivityWillSave:)]
        unsafe fn userActivityWillSave(&self, user_activity: &NSUserActivity);

        #[optional]
        #[method(userActivityWasContinued:)]
        unsafe fn userActivityWasContinued(&self, user_activity: &NSUserActivity);

        #[cfg(feature = "NSStream")]
        #[optional]
        #[method(userActivity:didReceiveInputStream:outputStream:)]
        unsafe fn userActivity_didReceiveInputStream_outputStream(
            &self,
            user_activity: &NSUserActivity,
            input_stream: &NSInputStream,
            output_stream: &NSOutputStream,
        );
    }

    unsafe impl ProtocolType for dyn NSUserActivityDelegate {}
);
