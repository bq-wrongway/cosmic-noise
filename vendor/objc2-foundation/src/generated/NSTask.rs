//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2::__framework_prelude::*;

use crate::*;

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSTaskTerminationReason(pub NSInteger);
impl NSTaskTerminationReason {
    #[doc(alias = "NSTaskTerminationReasonExit")]
    pub const Exit: Self = Self(1);
    #[doc(alias = "NSTaskTerminationReasonUncaughtSignal")]
    pub const UncaughtSignal: Self = Self(2);
}

unsafe impl Encode for NSTaskTerminationReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSTaskTerminationReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSTask;

    unsafe impl ClassType for NSTask {
        type Super = NSObject;
        type Mutability = InteriorMutable;
    }
);

unsafe impl Send for NSTask {}

unsafe impl Sync for NSTask {}

unsafe impl NSObjectProtocol for NSTask {}

extern_methods!(
    unsafe impl NSTask {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSURL")]
        #[method_id(@__retain_semantics Other executableURL)]
        pub unsafe fn executableURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[method(setExecutableURL:)]
        pub unsafe fn setExecutableURL(&self, executable_url: Option<&NSURL>);

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[method_id(@__retain_semantics Other arguments)]
        pub unsafe fn arguments(&self) -> Option<Retained<NSArray<NSString>>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[method(setArguments:)]
        pub unsafe fn setArguments(&self, arguments: Option<&NSArray<NSString>>);

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[method_id(@__retain_semantics Other environment)]
        pub unsafe fn environment(&self) -> Option<Retained<NSDictionary<NSString, NSString>>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[method(setEnvironment:)]
        pub unsafe fn setEnvironment(&self, environment: Option<&NSDictionary<NSString, NSString>>);

        #[cfg(feature = "NSURL")]
        #[method_id(@__retain_semantics Other currentDirectoryURL)]
        pub unsafe fn currentDirectoryURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[method(setCurrentDirectoryURL:)]
        pub unsafe fn setCurrentDirectoryURL(&self, current_directory_url: Option<&NSURL>);

        #[cfg(feature = "NSData")]
        #[method_id(@__retain_semantics Other launchRequirementData)]
        pub unsafe fn launchRequirementData(&self) -> Option<Retained<NSData>>;

        #[cfg(feature = "NSData")]
        #[method(setLaunchRequirementData:)]
        pub unsafe fn setLaunchRequirementData(&self, launch_requirement_data: Option<&NSData>);

        #[method_id(@__retain_semantics Other standardInput)]
        pub unsafe fn standardInput(&self) -> Option<Retained<AnyObject>>;

        #[method(setStandardInput:)]
        pub unsafe fn setStandardInput(&self, standard_input: Option<&AnyObject>);

        #[method_id(@__retain_semantics Other standardOutput)]
        pub unsafe fn standardOutput(&self) -> Option<Retained<AnyObject>>;

        #[method(setStandardOutput:)]
        pub unsafe fn setStandardOutput(&self, standard_output: Option<&AnyObject>);

        #[method_id(@__retain_semantics Other standardError)]
        pub unsafe fn standardError(&self) -> Option<Retained<AnyObject>>;

        #[method(setStandardError:)]
        pub unsafe fn setStandardError(&self, standard_error: Option<&AnyObject>);

        #[cfg(feature = "NSError")]
        #[method(launchAndReturnError:_)]
        pub unsafe fn launchAndReturnError(&self) -> Result<(), Retained<NSError>>;

        #[method(interrupt)]
        pub unsafe fn interrupt(&self);

        #[method(terminate)]
        pub unsafe fn terminate(&self);

        #[method(suspend)]
        pub unsafe fn suspend(&self) -> bool;

        #[method(resume)]
        pub unsafe fn resume(&self) -> bool;

        #[method(processIdentifier)]
        pub unsafe fn processIdentifier(&self) -> c_int;

        #[method(isRunning)]
        pub unsafe fn isRunning(&self) -> bool;

        #[method(terminationStatus)]
        pub unsafe fn terminationStatus(&self) -> c_int;

        #[method(terminationReason)]
        pub unsafe fn terminationReason(&self) -> NSTaskTerminationReason;

        #[cfg(feature = "block2")]
        #[method(terminationHandler)]
        pub unsafe fn terminationHandler(&self) -> *mut block2::Block<dyn Fn(NonNull<NSTask>)>;

        #[cfg(feature = "block2")]
        #[method(setTerminationHandler:)]
        pub unsafe fn setTerminationHandler(
            &self,
            termination_handler: Option<&block2::Block<dyn Fn(NonNull<NSTask>)>>,
        );

        #[cfg(feature = "NSObjCRuntime")]
        #[method(qualityOfService)]
        pub unsafe fn qualityOfService(&self) -> NSQualityOfService;

        #[cfg(feature = "NSObjCRuntime")]
        #[method(setQualityOfService:)]
        pub unsafe fn setQualityOfService(&self, quality_of_service: NSQualityOfService);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSTask {
        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_methods!(
    /// NSTaskConveniences
    unsafe impl NSTask {
        #[cfg(all(
            feature = "NSArray",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL",
            feature = "block2"
        ))]
        #[method_id(@__retain_semantics Other launchedTaskWithExecutableURL:arguments:error:terminationHandler:)]
        pub unsafe fn launchedTaskWithExecutableURL_arguments_error_terminationHandler(
            url: &NSURL,
            arguments: &NSArray<NSString>,
            error: Option<&mut Option<Retained<NSError>>>,
            termination_handler: Option<&block2::Block<dyn Fn(NonNull<NSTask>)>>,
        ) -> Option<Retained<NSTask>>;

        #[method(waitUntilExit)]
        pub unsafe fn waitUntilExit(&self);
    }
);

extern_methods!(
    /// NSDeprecated
    unsafe impl NSTask {
        #[cfg(feature = "NSString")]
        #[deprecated]
        #[method_id(@__retain_semantics Other launchPath)]
        pub unsafe fn launchPath(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[deprecated]
        #[method(setLaunchPath:)]
        pub unsafe fn setLaunchPath(&self, launch_path: Option<&NSString>);

        #[cfg(feature = "NSString")]
        #[deprecated]
        #[method_id(@__retain_semantics Other currentDirectoryPath)]
        pub unsafe fn currentDirectoryPath(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[deprecated]
        #[method(setCurrentDirectoryPath:)]
        pub unsafe fn setCurrentDirectoryPath(&self, current_directory_path: &NSString);

        #[deprecated]
        #[method(launch)]
        pub unsafe fn launch(&self);

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[deprecated]
        #[method_id(@__retain_semantics Other launchedTaskWithLaunchPath:arguments:)]
        pub unsafe fn launchedTaskWithLaunchPath_arguments(
            path: &NSString,
            arguments: &NSArray<NSString>,
        ) -> Retained<NSTask>;
    }
);

extern "C" {
    #[cfg(all(feature = "NSNotification", feature = "NSString"))]
    pub static NSTaskDidTerminateNotification: &'static NSNotificationName;
}
