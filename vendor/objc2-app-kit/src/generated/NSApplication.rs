//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

// NS_TYPED_EXTENSIBLE_ENUM
pub type NSAppKitVersion = c_double;

extern "C" {
    pub static NSAppKitVersionNumber: NSAppKitVersion;
}

pub static NSAppKitVersionNumber10_0: NSAppKitVersion = 577 as _;

pub static NSAppKitVersionNumber10_1: NSAppKitVersion = 620 as _;

pub static NSAppKitVersionNumber10_2: NSAppKitVersion = 663 as _;

pub static NSAppKitVersionNumber10_2_3: NSAppKitVersion = 663.6 as _;

pub static NSAppKitVersionNumber10_3: NSAppKitVersion = 743 as _;

pub static NSAppKitVersionNumber10_3_2: NSAppKitVersion = 743.14 as _;

pub static NSAppKitVersionNumber10_3_3: NSAppKitVersion = 743.2 as _;

pub static NSAppKitVersionNumber10_3_5: NSAppKitVersion = 743.24 as _;

pub static NSAppKitVersionNumber10_3_7: NSAppKitVersion = 743.33 as _;

pub static NSAppKitVersionNumber10_3_9: NSAppKitVersion = 743.36 as _;

pub static NSAppKitVersionNumber10_4: NSAppKitVersion = 824 as _;

pub static NSAppKitVersionNumber10_4_1: NSAppKitVersion = 824.1 as _;

pub static NSAppKitVersionNumber10_4_3: NSAppKitVersion = 824.23 as _;

pub static NSAppKitVersionNumber10_4_4: NSAppKitVersion = 824.33 as _;

pub static NSAppKitVersionNumber10_4_7: NSAppKitVersion = 824.41 as _;

pub static NSAppKitVersionNumber10_5: NSAppKitVersion = 949 as _;

pub static NSAppKitVersionNumber10_5_2: NSAppKitVersion = 949.27 as _;

pub static NSAppKitVersionNumber10_5_3: NSAppKitVersion = 949.33 as _;

pub static NSAppKitVersionNumber10_6: NSAppKitVersion = 1038 as _;

pub static NSAppKitVersionNumber10_7: NSAppKitVersion = 1138 as _;

pub static NSAppKitVersionNumber10_7_2: NSAppKitVersion = 1138.23 as _;

pub static NSAppKitVersionNumber10_7_3: NSAppKitVersion = 1138.32 as _;

pub static NSAppKitVersionNumber10_7_4: NSAppKitVersion = 1138.47 as _;

pub static NSAppKitVersionNumber10_8: NSAppKitVersion = 1187 as _;

pub static NSAppKitVersionNumber10_9: NSAppKitVersion = 1265 as _;

pub static NSAppKitVersionNumber10_10: NSAppKitVersion = 1343 as _;

pub static NSAppKitVersionNumber10_10_2: NSAppKitVersion = 1344 as _;

pub static NSAppKitVersionNumber10_10_3: NSAppKitVersion = 1347 as _;

pub static NSAppKitVersionNumber10_10_4: NSAppKitVersion = 1348 as _;

pub static NSAppKitVersionNumber10_10_5: NSAppKitVersion = 1348 as _;

pub static NSAppKitVersionNumber10_10_Max: NSAppKitVersion = 1349 as _;

pub static NSAppKitVersionNumber10_11: NSAppKitVersion = 1404 as _;

pub static NSAppKitVersionNumber10_11_1: NSAppKitVersion = 1404.13 as _;

pub static NSAppKitVersionNumber10_11_2: NSAppKitVersion = 1404.34 as _;

pub static NSAppKitVersionNumber10_11_3: NSAppKitVersion = 1404.34 as _;

pub static NSAppKitVersionNumber10_12: NSAppKitVersion = 1504 as _;

pub static NSAppKitVersionNumber10_12_1: NSAppKitVersion = 1504.6 as _;

pub static NSAppKitVersionNumber10_12_2: NSAppKitVersion = 1504.76 as _;

pub static NSAppKitVersionNumber10_13: NSAppKitVersion = 1561 as _;

pub static NSAppKitVersionNumber10_13_1: NSAppKitVersion = 1561.1 as _;

pub static NSAppKitVersionNumber10_13_2: NSAppKitVersion = 1561.2 as _;

pub static NSAppKitVersionNumber10_13_4: NSAppKitVersion = 1561.4 as _;

pub static NSAppKitVersionNumber10_14: NSAppKitVersion = 1671 as _;

pub static NSAppKitVersionNumber10_14_1: NSAppKitVersion = 1671.1 as _;

pub static NSAppKitVersionNumber10_14_2: NSAppKitVersion = 1671.2 as _;

pub static NSAppKitVersionNumber10_14_3: NSAppKitVersion = 1671.3 as _;

pub static NSAppKitVersionNumber10_14_4: NSAppKitVersion = 1671.4 as _;

pub static NSAppKitVersionNumber10_14_5: NSAppKitVersion = 1671.5 as _;

pub static NSAppKitVersionNumber10_15: NSAppKitVersion = 1894 as _;

pub static NSAppKitVersionNumber10_15_1: NSAppKitVersion = 1894.1 as _;

pub static NSAppKitVersionNumber10_15_2: NSAppKitVersion = 1894.2 as _;

pub static NSAppKitVersionNumber10_15_3: NSAppKitVersion = 1894.3 as _;

pub static NSAppKitVersionNumber10_15_4: NSAppKitVersion = 1894.4 as _;

pub static NSAppKitVersionNumber10_15_5: NSAppKitVersion = 1894.5 as _;

pub static NSAppKitVersionNumber10_15_6: NSAppKitVersion = 1894.6 as _;

pub static NSAppKitVersionNumber11_0: NSAppKitVersion = 2022 as _;

pub static NSAppKitVersionNumber11_1: NSAppKitVersion = 2022.2 as _;

pub static NSAppKitVersionNumber11_2: NSAppKitVersion = 2022.3 as _;

pub static NSAppKitVersionNumber11_3: NSAppKitVersion = 2022.4 as _;

pub static NSAppKitVersionNumber11_4: NSAppKitVersion = 2022.5 as _;

pub static NSAppKitVersionNumber11_5: NSAppKitVersion = 2022.6 as _;

pub static NSAppKitVersionNumber12_0: NSAppKitVersion = 2113 as _;

pub static NSAppKitVersionNumber12_1: NSAppKitVersion = 2113.2 as _;

pub static NSAppKitVersionNumber12_2: NSAppKitVersion = 2113.3 as _;

pub static NSAppKitVersionNumber12_3: NSAppKitVersion = 2113.4 as _;

pub static NSAppKitVersionNumber12_4: NSAppKitVersion = 2113.5 as _;

pub static NSAppKitVersionNumber12_5: NSAppKitVersion = 2113.6 as _;

pub static NSAppKitVersionNumber13_0: NSAppKitVersion = 2299 as _;

pub static NSAppKitVersionNumber13_1: NSAppKitVersion = 2299.3 as _;

pub static NSAppKitVersionNumber13_2: NSAppKitVersion = 2299.3 as _;

pub static NSAppKitVersionNumber13_3: NSAppKitVersion = 2299.4 as _;

pub static NSAppKitVersionNumber13_4: NSAppKitVersion = 2299.5 as _;

pub static NSAppKitVersionNumber13_5: NSAppKitVersion = 2299.6 as _;

pub static NSAppKitVersionNumber13_6: NSAppKitVersion = 2299.7 as _;

pub static NSAppKitVersionNumber14_0: NSAppKitVersion = 2487 as _;

pub static NSAppKitVersionNumber14_1: NSAppKitVersion = 2487.2 as _;

extern "C" {
    pub static NSModalPanelRunLoopMode: &'static NSRunLoopMode;
}

extern "C" {
    pub static NSEventTrackingRunLoopMode: &'static NSRunLoopMode;
}

// NS_TYPED_EXTENSIBLE_ENUM
pub type NSModalResponse = NSInteger;

pub static NSModalResponseStop: NSModalResponse = -1000;

pub static NSModalResponseAbort: NSModalResponse = -1001;

pub static NSModalResponseContinue: NSModalResponse = -1002;

pub const NSUpdateWindowsRunLoopOrdering: c_uint = 500000;

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationPresentationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSApplicationPresentationOptions: NSUInteger {
        const NSApplicationPresentationDefault = 0;
        const NSApplicationPresentationAutoHideDock = 1<<0;
        const NSApplicationPresentationHideDock = 1<<1;
        const NSApplicationPresentationAutoHideMenuBar = 1<<2;
        const NSApplicationPresentationHideMenuBar = 1<<3;
        const NSApplicationPresentationDisableAppleMenu = 1<<4;
        const NSApplicationPresentationDisableProcessSwitching = 1<<5;
        const NSApplicationPresentationDisableForceQuit = 1<<6;
        const NSApplicationPresentationDisableSessionTermination = 1<<7;
        const NSApplicationPresentationDisableHideApplication = 1<<8;
        const NSApplicationPresentationDisableMenuBarTransparency = 1<<9;
        const NSApplicationPresentationFullScreen = 1<<10;
        const NSApplicationPresentationAutoHideToolbar = 1<<11;
        const NSApplicationPresentationDisableCursorLocationAssistance = 1<<12;
    }
}

unsafe impl Encode for NSApplicationPresentationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationPresentationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationOcclusionState(pub NSUInteger);
bitflags::bitflags! {
    impl NSApplicationOcclusionState: NSUInteger {
        #[doc(alias = "NSApplicationOcclusionStateVisible")]
        const Visible = 1<<1;
    }
}

unsafe impl Encode for NSApplicationOcclusionState {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationOcclusionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSWindowListOptions(pub NSInteger);
bitflags::bitflags! {
    impl NSWindowListOptions: NSInteger {
        const NSWindowListOrderedFrontToBack = 1<<0;
    }
}

unsafe impl Encode for NSWindowListOptions {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSWindowListOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type NSModalSession = *mut c_void;

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSRequestUserAttentionType(pub NSUInteger);
impl NSRequestUserAttentionType {
    pub const NSCriticalRequest: Self = Self(0);
    pub const NSInformationalRequest: Self = Self(10);
}

unsafe impl Encode for NSRequestUserAttentionType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSRequestUserAttentionType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationDelegateReply(pub NSUInteger);
impl NSApplicationDelegateReply {
    #[doc(alias = "NSApplicationDelegateReplySuccess")]
    pub const Success: Self = Self(0);
    #[doc(alias = "NSApplicationDelegateReplyCancel")]
    pub const Cancel: Self = Self(1);
    #[doc(alias = "NSApplicationDelegateReplyFailure")]
    pub const Failure: Self = Self(2);
}

unsafe impl Encode for NSApplicationDelegateReply {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationDelegateReply {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSResponder")]
    pub struct NSApplication;

    #[cfg(feature = "NSResponder")]
    unsafe impl ClassType for NSApplication {
        #[inherits(NSObject)]
        type Super = NSResponder;
        type Mutability = MainThreadOnly;
    }
);

#[cfg(all(feature = "NSAccessibilityProtocols", feature = "NSResponder"))]
unsafe impl NSAccessibility for NSApplication {}

#[cfg(all(feature = "NSAccessibilityProtocols", feature = "NSResponder"))]
unsafe impl NSAccessibilityElementProtocol for NSApplication {}

#[cfg(feature = "NSResponder")]
unsafe impl NSCoding for NSApplication {}

#[cfg(all(feature = "NSMenu", feature = "NSResponder"))]
unsafe impl NSMenuItemValidation for NSApplication {}

#[cfg(feature = "NSResponder")]
unsafe impl NSObjectProtocol for NSApplication {}

#[cfg(all(feature = "NSResponder", feature = "NSUserInterfaceValidation"))]
unsafe impl NSUserInterfaceValidations for NSApplication {}

extern_methods!(
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method_id(@__retain_semantics Other sharedApplication)]
        pub fn sharedApplication(mtm: MainThreadMarker) -> Retained<NSApplication>;

        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSApplicationDelegate>>>;

        #[method(setDelegate:)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSApplicationDelegate>>);

        #[method(hide:)]
        pub fn hide(&self, sender: Option<&AnyObject>);

        #[method(unhide:)]
        pub unsafe fn unhide(&self, sender: Option<&AnyObject>);

        #[method(unhideWithoutActivation)]
        pub unsafe fn unhideWithoutActivation(&self);

        #[cfg(feature = "NSWindow")]
        #[method_id(@__retain_semantics Other windowWithWindowNumber:)]
        pub unsafe fn windowWithWindowNumber(
            &self,
            window_num: NSInteger,
        ) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        #[method_id(@__retain_semantics Other mainWindow)]
        pub unsafe fn mainWindow(&self) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        #[method_id(@__retain_semantics Other keyWindow)]
        pub fn keyWindow(&self) -> Option<Retained<NSWindow>>;

        #[method(isActive)]
        pub unsafe fn isActive(&self) -> bool;

        #[method(isHidden)]
        pub unsafe fn isHidden(&self) -> bool;

        #[method(isRunning)]
        pub unsafe fn isRunning(&self) -> bool;

        #[method(deactivate)]
        pub unsafe fn deactivate(&self);

        #[deprecated = "This method will be deprecated in a future release. Use NSApp.activate instead."]
        #[method(activateIgnoringOtherApps:)]
        pub fn activateIgnoringOtherApps(&self, flag: bool);

        #[method(activate)]
        pub unsafe fn activate(&self);

        #[cfg(feature = "NSRunningApplication")]
        #[method(yieldActivationToApplication:)]
        pub unsafe fn yieldActivationToApplication(&self, application: &NSRunningApplication);

        #[method(yieldActivationToApplicationWithBundleIdentifier:)]
        pub unsafe fn yieldActivationToApplicationWithBundleIdentifier(
            &self,
            bundle_identifier: &NSString,
        );

        #[method(hideOtherApplications:)]
        pub fn hideOtherApplications(&self, sender: Option<&AnyObject>);

        #[method(unhideAllApplications:)]
        pub unsafe fn unhideAllApplications(&self, sender: Option<&AnyObject>);

        #[method(finishLaunching)]
        pub unsafe fn finishLaunching(&self);

        #[method(run)]
        pub unsafe fn run(&self);

        #[cfg(feature = "NSWindow")]
        #[method(runModalForWindow:)]
        pub unsafe fn runModalForWindow(&self, window: &NSWindow) -> NSModalResponse;

        #[method(stop:)]
        pub fn stop(&self, sender: Option<&AnyObject>);

        #[method(stopModal)]
        pub unsafe fn stopModal(&self);

        #[method(stopModalWithCode:)]
        pub unsafe fn stopModalWithCode(&self, return_code: NSModalResponse);

        #[method(abortModal)]
        pub unsafe fn abortModal(&self);

        #[cfg(feature = "NSWindow")]
        #[method_id(@__retain_semantics Other modalWindow)]
        pub unsafe fn modalWindow(&self) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        #[method(beginModalSessionForWindow:)]
        pub unsafe fn beginModalSessionForWindow(&self, window: &NSWindow) -> NSModalSession;

        #[method(runModalSession:)]
        pub unsafe fn runModalSession(&self, session: NSModalSession) -> NSModalResponse;

        #[method(endModalSession:)]
        pub unsafe fn endModalSession(&self, session: NSModalSession);

        #[method(terminate:)]
        pub unsafe fn terminate(&self, sender: Option<&AnyObject>);

        #[method(requestUserAttention:)]
        pub fn requestUserAttention(&self, request_type: NSRequestUserAttentionType) -> NSInteger;

        #[method(cancelUserAttentionRequest:)]
        pub unsafe fn cancelUserAttentionRequest(&self, request: NSInteger);

        #[cfg(all(feature = "NSWindow", feature = "block2"))]
        #[method(enumerateWindowsWithOptions:usingBlock:)]
        pub unsafe fn enumerateWindowsWithOptions_usingBlock(
            &self,
            options: NSWindowListOptions,
            block: &block2::Block<dyn Fn(NonNull<NSWindow>, NonNull<Bool>) + '_>,
        );

        #[method(preventWindowOrdering)]
        pub unsafe fn preventWindowOrdering(&self);

        #[cfg(feature = "NSWindow")]
        #[method_id(@__retain_semantics Other windows)]
        pub fn windows(&self) -> Retained<NSArray<NSWindow>>;

        #[method(setWindowsNeedUpdate:)]
        pub unsafe fn setWindowsNeedUpdate(&self, need_update: bool);

        #[method(updateWindows)]
        pub unsafe fn updateWindows(&self);

        #[cfg(feature = "NSMenu")]
        #[method_id(@__retain_semantics Other mainMenu)]
        pub unsafe fn mainMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        #[method(setMainMenu:)]
        pub fn setMainMenu(&self, main_menu: Option<&NSMenu>);

        #[cfg(feature = "NSMenu")]
        #[method_id(@__retain_semantics Other helpMenu)]
        pub unsafe fn helpMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        #[method(setHelpMenu:)]
        pub unsafe fn setHelpMenu(&self, help_menu: Option<&NSMenu>);

        #[cfg(feature = "NSImage")]
        #[method_id(@__retain_semantics Other applicationIconImage)]
        pub unsafe fn applicationIconImage(&self) -> Option<Retained<NSImage>>;

        #[cfg(feature = "NSImage")]
        #[method(setApplicationIconImage:)]
        pub unsafe fn setApplicationIconImage(&self, application_icon_image: Option<&NSImage>);

        #[cfg(feature = "NSRunningApplication")]
        #[method(activationPolicy)]
        pub unsafe fn activationPolicy(&self) -> NSApplicationActivationPolicy;

        #[cfg(feature = "NSRunningApplication")]
        #[method(setActivationPolicy:)]
        pub fn setActivationPolicy(&self, activation_policy: NSApplicationActivationPolicy)
            -> bool;

        #[cfg(feature = "NSDockTile")]
        #[method_id(@__retain_semantics Other dockTile)]
        pub unsafe fn dockTile(&self) -> Retained<NSDockTile>;

        #[method(reportException:)]
        pub unsafe fn reportException(&self, exception: &NSException);

        #[method(detachDrawingThread:toTarget:withObject:)]
        pub unsafe fn detachDrawingThread_toTarget_withObject(
            selector: Sel,
            target: &AnyObject,
            argument: Option<&AnyObject>,
            mtm: MainThreadMarker,
        );

        #[method(replyToApplicationShouldTerminate:)]
        pub unsafe fn replyToApplicationShouldTerminate(&self, should_terminate: bool);

        #[method(replyToOpenOrPrint:)]
        pub unsafe fn replyToOpenOrPrint(&self, reply: NSApplicationDelegateReply);

        #[method(orderFrontCharacterPalette:)]
        pub fn orderFrontCharacterPalette(&self, sender: Option<&AnyObject>);

        #[method(presentationOptions)]
        pub fn presentationOptions(&self) -> NSApplicationPresentationOptions;

        #[method(setPresentationOptions:)]
        pub fn setPresentationOptions(
            &self,
            presentation_options: NSApplicationPresentationOptions,
        );

        #[method(currentSystemPresentationOptions)]
        pub unsafe fn currentSystemPresentationOptions(&self) -> NSApplicationPresentationOptions;

        #[method(occlusionState)]
        pub unsafe fn occlusionState(&self) -> NSApplicationOcclusionState;

        #[method(isProtectedDataAvailable)]
        pub unsafe fn isProtectedDataAvailable(&self) -> bool;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSResponder`
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_methods!(
    /// NSAppearanceCustomization
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSAppearance")]
        #[method_id(@__retain_semantics Other appearance)]
        pub unsafe fn appearance(&self) -> Option<Retained<NSAppearance>>;

        #[cfg(feature = "NSAppearance")]
        #[method(setAppearance:)]
        pub fn setAppearance(&self, appearance: Option<&NSAppearance>);

        #[cfg(feature = "NSAppearance")]
        #[method_id(@__retain_semantics Other effectiveAppearance)]
        pub fn effectiveAppearance(&self) -> Retained<NSAppearance>;
    }
);

#[cfg(all(feature = "NSAppearance", feature = "NSResponder"))]
unsafe impl NSAppearanceCustomization for NSApplication {}

extern_methods!(
    /// NSEvent
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSEvent")]
        #[method(sendEvent:)]
        pub unsafe fn sendEvent(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[method(postEvent:atStart:)]
        pub fn postEvent_atStart(&self, event: &NSEvent, flag: bool);

        #[cfg(feature = "NSEvent")]
        #[method_id(@__retain_semantics Other currentEvent)]
        pub fn currentEvent(&self) -> Option<Retained<NSEvent>>;

        #[cfg(feature = "NSEvent")]
        #[method_id(@__retain_semantics Other nextEventMatchingMask:untilDate:inMode:dequeue:)]
        pub unsafe fn nextEventMatchingMask_untilDate_inMode_dequeue(
            &self,
            mask: NSEventMask,
            expiration: Option<&NSDate>,
            mode: &NSRunLoopMode,
            deq_flag: bool,
        ) -> Option<Retained<NSEvent>>;

        #[cfg(feature = "NSEvent")]
        #[method(discardEventsMatchingMask:beforeEvent:)]
        pub unsafe fn discardEventsMatchingMask_beforeEvent(
            &self,
            mask: NSEventMask,
            last_event: Option<&NSEvent>,
        );
    }
);

extern_methods!(
    /// NSResponder
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method(sendAction:to:from:)]
        pub unsafe fn sendAction_to_from(
            &self,
            action: Sel,
            target: Option<&AnyObject>,
            sender: Option<&AnyObject>,
        ) -> bool;

        #[method_id(@__retain_semantics Other targetForAction:)]
        pub unsafe fn targetForAction(&self, action: Sel) -> Option<Retained<AnyObject>>;

        #[method_id(@__retain_semantics Other targetForAction:to:from:)]
        pub unsafe fn targetForAction_to_from(
            &self,
            action: Sel,
            target: Option<&AnyObject>,
            sender: Option<&AnyObject>,
        ) -> Option<Retained<AnyObject>>;

        #[method(tryToPerform:with:)]
        pub unsafe fn tryToPerform_with(&self, action: Sel, object: Option<&AnyObject>) -> bool;

        #[cfg(feature = "NSPasteboard")]
        #[method_id(@__retain_semantics Other validRequestorForSendType:returnType:)]
        pub unsafe fn validRequestorForSendType_returnType(
            &self,
            send_type: Option<&NSPasteboardType>,
            return_type: Option<&NSPasteboardType>,
        ) -> Option<Retained<AnyObject>>;
    }
);

extern_methods!(
    /// NSWindowsMenu
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSMenu")]
        #[method_id(@__retain_semantics Other windowsMenu)]
        pub unsafe fn windowsMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        #[method(setWindowsMenu:)]
        pub unsafe fn setWindowsMenu(&self, windows_menu: Option<&NSMenu>);

        #[method(arrangeInFront:)]
        pub unsafe fn arrangeInFront(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "NSWindow")]
        #[method(removeWindowsItem:)]
        pub unsafe fn removeWindowsItem(&self, win: &NSWindow);

        #[cfg(feature = "NSWindow")]
        #[method(addWindowsItem:title:filename:)]
        pub unsafe fn addWindowsItem_title_filename(
            &self,
            win: &NSWindow,
            string: &NSString,
            is_filename: bool,
        );

        #[cfg(feature = "NSWindow")]
        #[method(changeWindowsItem:title:filename:)]
        pub unsafe fn changeWindowsItem_title_filename(
            &self,
            win: &NSWindow,
            string: &NSString,
            is_filename: bool,
        );

        #[cfg(feature = "NSWindow")]
        #[method(updateWindowsItem:)]
        pub unsafe fn updateWindowsItem(&self, win: &NSWindow);

        #[method(miniaturizeAll:)]
        pub unsafe fn miniaturizeAll(&self, sender: Option<&AnyObject>);
    }
);

extern_methods!(
    /// NSFullKeyboardAccess
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method(isFullKeyboardAccessEnabled)]
        pub unsafe fn isFullKeyboardAccessEnabled(&self) -> bool;
    }
);

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationTerminateReply(pub NSUInteger);
impl NSApplicationTerminateReply {
    pub const NSTerminateCancel: Self = Self(0);
    pub const NSTerminateNow: Self = Self(1);
    pub const NSTerminateLater: Self = Self(2);
}

unsafe impl Encode for NSApplicationTerminateReply {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationTerminateReply {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationPrintReply(pub NSUInteger);
impl NSApplicationPrintReply {
    pub const NSPrintingCancelled: Self = Self(0);
    pub const NSPrintingSuccess: Self = Self(1);
    pub const NSPrintingReplyLater: Self = Self(2);
    pub const NSPrintingFailure: Self = Self(3);
}

unsafe impl Encode for NSApplicationPrintReply {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationPrintReply {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    pub unsafe trait NSApplicationDelegate: NSObjectProtocol + IsMainThreadOnly {
        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationShouldTerminate:)]
        unsafe fn applicationShouldTerminate(
            &self,
            sender: &NSApplication,
        ) -> NSApplicationTerminateReply;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:openURLs:)]
        unsafe fn application_openURLs(&self, application: &NSApplication, urls: &NSArray<NSURL>);

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:openFile:)]
        unsafe fn application_openFile(&self, sender: &NSApplication, filename: &NSString) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:openFiles:)]
        unsafe fn application_openFiles(
            &self,
            sender: &NSApplication,
            filenames: &NSArray<NSString>,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:openTempFile:)]
        unsafe fn application_openTempFile(
            &self,
            sender: &NSApplication,
            filename: &NSString,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationShouldOpenUntitledFile:)]
        unsafe fn applicationShouldOpenUntitledFile(&self, sender: &NSApplication) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationOpenUntitledFile:)]
        unsafe fn applicationOpenUntitledFile(&self, sender: &NSApplication) -> bool;

        #[optional]
        #[method(application:openFileWithoutUI:)]
        unsafe fn application_openFileWithoutUI(
            &self,
            sender: &AnyObject,
            filename: &NSString,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:printFile:)]
        unsafe fn application_printFile(&self, sender: &NSApplication, filename: &NSString)
            -> bool;

        #[cfg(all(feature = "NSPrintInfo", feature = "NSResponder"))]
        #[optional]
        #[method(application:printFiles:withSettings:showPrintPanels:)]
        unsafe fn application_printFiles_withSettings_showPrintPanels(
            &self,
            application: &NSApplication,
            file_names: &NSArray<NSString>,
            print_settings: &NSDictionary<NSPrintInfoAttributeKey, AnyObject>,
            show_print_panels: bool,
        ) -> NSApplicationPrintReply;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationShouldTerminateAfterLastWindowClosed:)]
        unsafe fn applicationShouldTerminateAfterLastWindowClosed(
            &self,
            sender: &NSApplication,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationShouldHandleReopen:hasVisibleWindows:)]
        unsafe fn applicationShouldHandleReopen_hasVisibleWindows(
            &self,
            sender: &NSApplication,
            flag: bool,
        ) -> bool;

        #[cfg(all(feature = "NSMenu", feature = "NSResponder"))]
        #[optional]
        #[method_id(@__retain_semantics Other applicationDockMenu:)]
        unsafe fn applicationDockMenu(&self, sender: &NSApplication) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method_id(@__retain_semantics Other application:willPresentError:)]
        unsafe fn application_willPresentError(
            &self,
            application: &NSApplication,
            error: &NSError,
        ) -> Retained<NSError>;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:didRegisterForRemoteNotificationsWithDeviceToken:)]
        unsafe fn application_didRegisterForRemoteNotificationsWithDeviceToken(
            &self,
            application: &NSApplication,
            device_token: &NSData,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:didFailToRegisterForRemoteNotificationsWithError:)]
        unsafe fn application_didFailToRegisterForRemoteNotificationsWithError(
            &self,
            application: &NSApplication,
            error: &NSError,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:didReceiveRemoteNotification:)]
        unsafe fn application_didReceiveRemoteNotification(
            &self,
            application: &NSApplication,
            user_info: &NSDictionary<NSString, AnyObject>,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationSupportsSecureRestorableState:)]
        unsafe fn applicationSupportsSecureRestorableState(&self, app: &NSApplication) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:willEncodeRestorableState:)]
        unsafe fn application_willEncodeRestorableState(
            &self,
            app: &NSApplication,
            coder: &NSCoder,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:didDecodeRestorableState:)]
        unsafe fn application_didDecodeRestorableState(&self, app: &NSApplication, coder: &NSCoder);

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:willContinueUserActivityWithType:)]
        unsafe fn application_willContinueUserActivityWithType(
            &self,
            application: &NSApplication,
            user_activity_type: &NSString,
        ) -> bool;

        #[cfg(all(
            feature = "NSResponder",
            feature = "NSUserActivity",
            feature = "block2"
        ))]
        #[optional]
        #[method(application:continueUserActivity:restorationHandler:)]
        unsafe fn application_continueUserActivity_restorationHandler(
            &self,
            application: &NSApplication,
            user_activity: &NSUserActivity,
            restoration_handler: &block2::Block<
                dyn Fn(NonNull<NSArray<ProtocolObject<dyn NSUserActivityRestoring>>>),
            >,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:didFailToContinueUserActivityWithType:error:)]
        unsafe fn application_didFailToContinueUserActivityWithType_error(
            &self,
            application: &NSApplication,
            user_activity_type: &NSString,
            error: &NSError,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:didUpdateUserActivity:)]
        unsafe fn application_didUpdateUserActivity(
            &self,
            application: &NSApplication,
            user_activity: &NSUserActivity,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:delegateHandlesKey:)]
        unsafe fn application_delegateHandlesKey(
            &self,
            sender: &NSApplication,
            key: &NSString,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationShouldAutomaticallyLocalizeKeyEquivalents:)]
        unsafe fn applicationShouldAutomaticallyLocalizeKeyEquivalents(
            &self,
            application: &NSApplication,
        ) -> bool;

        #[optional]
        #[method(applicationWillFinishLaunching:)]
        unsafe fn applicationWillFinishLaunching(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidFinishLaunching:)]
        unsafe fn applicationDidFinishLaunching(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillHide:)]
        unsafe fn applicationWillHide(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidHide:)]
        unsafe fn applicationDidHide(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillUnhide:)]
        unsafe fn applicationWillUnhide(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidUnhide:)]
        unsafe fn applicationDidUnhide(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillBecomeActive:)]
        unsafe fn applicationWillBecomeActive(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidBecomeActive:)]
        unsafe fn applicationDidBecomeActive(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillResignActive:)]
        unsafe fn applicationWillResignActive(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidResignActive:)]
        unsafe fn applicationDidResignActive(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillUpdate:)]
        unsafe fn applicationWillUpdate(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidUpdate:)]
        unsafe fn applicationDidUpdate(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillTerminate:)]
        unsafe fn applicationWillTerminate(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidChangeScreenParameters:)]
        unsafe fn applicationDidChangeScreenParameters(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidChangeOcclusionState:)]
        unsafe fn applicationDidChangeOcclusionState(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationProtectedDataWillBecomeUnavailable:)]
        unsafe fn applicationProtectedDataWillBecomeUnavailable(
            &self,
            notification: &NSNotification,
        );

        #[optional]
        #[method(applicationProtectedDataDidBecomeAvailable:)]
        unsafe fn applicationProtectedDataDidBecomeAvailable(&self, notification: &NSNotification);
    }

    unsafe impl ProtocolType for dyn NSApplicationDelegate {}
);

extern_methods!(
    /// NSServicesMenu
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSMenu")]
        #[method_id(@__retain_semantics Other servicesMenu)]
        pub unsafe fn servicesMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        #[method(setServicesMenu:)]
        pub unsafe fn setServicesMenu(&self, services_menu: Option<&NSMenu>);

        #[cfg(feature = "NSPasteboard")]
        #[method(registerServicesMenuSendTypes:returnTypes:)]
        pub unsafe fn registerServicesMenuSendTypes_returnTypes(
            &self,
            send_types: &NSArray<NSPasteboardType>,
            return_types: &NSArray<NSPasteboardType>,
        );
    }
);

extern_protocol!(
    pub unsafe trait NSServicesMenuRequestor: NSObjectProtocol {
        #[cfg(feature = "NSPasteboard")]
        #[optional]
        #[method(writeSelectionToPasteboard:types:)]
        unsafe fn writeSelectionToPasteboard_types(
            &self,
            pboard: &NSPasteboard,
            types: &NSArray<NSPasteboardType>,
        ) -> bool;

        #[cfg(feature = "NSPasteboard")]
        #[optional]
        #[method(readSelectionFromPasteboard:)]
        unsafe fn readSelectionFromPasteboard(&self, pboard: &NSPasteboard) -> bool;
    }

    unsafe impl ProtocolType for dyn NSServicesMenuRequestor {}
);

extern_methods!(
    /// NSServicesHandling
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method_id(@__retain_semantics Other servicesProvider)]
        pub unsafe fn servicesProvider(&self) -> Option<Retained<AnyObject>>;

        #[method(setServicesProvider:)]
        pub unsafe fn setServicesProvider(&self, services_provider: Option<&AnyObject>);
    }
);

// NS_TYPED_ENUM
pub type NSAboutPanelOptionKey = NSString;

extern "C" {
    pub static NSAboutPanelOptionCredits: &'static NSAboutPanelOptionKey;
}

extern "C" {
    pub static NSAboutPanelOptionApplicationName: &'static NSAboutPanelOptionKey;
}

extern "C" {
    pub static NSAboutPanelOptionApplicationIcon: &'static NSAboutPanelOptionKey;
}

extern "C" {
    pub static NSAboutPanelOptionVersion: &'static NSAboutPanelOptionKey;
}

extern "C" {
    pub static NSAboutPanelOptionApplicationVersion: &'static NSAboutPanelOptionKey;
}

extern_methods!(
    /// NSStandardAboutPanel
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method(orderFrontStandardAboutPanel:)]
        pub unsafe fn orderFrontStandardAboutPanel(&self, sender: Option<&AnyObject>);

        #[method(orderFrontStandardAboutPanelWithOptions:)]
        pub unsafe fn orderFrontStandardAboutPanelWithOptions(
            &self,
            options_dictionary: &NSDictionary<NSAboutPanelOptionKey, AnyObject>,
        );
    }
);

extern_methods!(
    /// NSApplicationLayoutDirection
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSUserInterfaceLayout")]
        #[method(userInterfaceLayoutDirection)]
        pub unsafe fn userInterfaceLayoutDirection(&self) -> NSUserInterfaceLayoutDirection;
    }
);

extern_methods!(
    /// NSRestorableUserInterface
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method(disableRelaunchOnLogin)]
        pub unsafe fn disableRelaunchOnLogin(&self);

        #[method(enableRelaunchOnLogin)]
        pub unsafe fn enableRelaunchOnLogin(&self);
    }
);

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSRemoteNotificationType(pub NSUInteger);
bitflags::bitflags! {
    impl NSRemoteNotificationType: NSUInteger {
        #[doc(alias = "NSRemoteNotificationTypeNone")]
        const None = 0;
        #[doc(alias = "NSRemoteNotificationTypeBadge")]
        const Badge = 1<<0;
        #[doc(alias = "NSRemoteNotificationTypeSound")]
        const Sound = 1<<1;
        #[doc(alias = "NSRemoteNotificationTypeAlert")]
        const Alert = 1<<2;
    }
}

unsafe impl Encode for NSRemoteNotificationType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSRemoteNotificationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_methods!(
    /// NSRemoteNotifications
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method(registerForRemoteNotifications)]
        pub unsafe fn registerForRemoteNotifications(&self);

        #[method(unregisterForRemoteNotifications)]
        pub unsafe fn unregisterForRemoteNotifications(&self);

        #[method(isRegisteredForRemoteNotifications)]
        pub unsafe fn isRegisteredForRemoteNotifications(&self) -> bool;

        #[method(registerForRemoteNotificationTypes:)]
        pub unsafe fn registerForRemoteNotificationTypes(&self, types: NSRemoteNotificationType);

        #[method(enabledRemoteNotificationTypes)]
        pub unsafe fn enabledRemoteNotificationTypes(&self) -> NSRemoteNotificationType;
    }
);

extern "C" {
    pub fn NSApplicationMain(argc: c_int, argv: NonNull<NonNull<c_char>>) -> c_int;
}

extern "C" {
    pub fn NSApplicationLoad() -> Bool;
}

extern "C" {
    pub fn NSShowsServicesMenuItem(item_name: &NSString) -> Bool;
}

extern "C" {
    pub fn NSSetShowsServicesMenuItem(item_name: &NSString, enabled: Bool) -> NSInteger;
}

extern "C" {
    pub fn NSUpdateDynamicServices();
}

extern "C" {
    #[cfg(feature = "NSPasteboard")]
    pub fn NSPerformService(item_name: &NSString, pboard: Option<&NSPasteboard>) -> Bool;
}

pub type NSServiceProviderName = NSString;

extern "C" {
    pub fn NSRegisterServicesProvider(provider: Option<&AnyObject>, name: &NSServiceProviderName);
}

extern "C" {
    pub fn NSUnregisterServicesProvider(name: &NSServiceProviderName);
}

extern "C" {
    pub static NSApplicationDidBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationDidHideNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationDidFinishLaunchingNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationDidResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationDidUnhideNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationDidUpdateNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationWillBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationWillHideNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationWillFinishLaunchingNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationWillResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationWillUnhideNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationWillUpdateNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationWillTerminateNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationDidChangeScreenParametersNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationProtectedDataWillBecomeUnavailableNotification:
        &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationProtectedDataDidBecomeAvailableNotification:
        &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationLaunchIsDefaultLaunchKey: &'static NSString;
}

extern "C" {
    pub static NSApplicationLaunchUserNotificationKey: &'static NSString;
}

extern "C" {
    pub static NSApplicationLaunchRemoteNotificationKey: &'static NSString;
}

extern "C" {
    pub static NSApplicationDidChangeOcclusionStateNotification: &'static NSNotificationName;
}

#[deprecated = "Use NSModalResponseStop instead"]
pub const NSRunStoppedResponse: c_int = -1000;
#[deprecated = "Use NSModalResponseAbort instead"]
pub const NSRunAbortedResponse: c_int = -1001;
#[deprecated = "Use NSModalResponseContinue instead"]
pub const NSRunContinuesResponse: c_int = -1002;

extern_methods!(
    /// NSDeprecated
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[method(runModalForWindow:relativeToWindow:)]
        pub unsafe fn runModalForWindow_relativeToWindow(
            &self,
            window: Option<&NSWindow>,
            doc_window: Option<&NSWindow>,
        ) -> NSInteger;

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[method(beginModalSessionForWindow:relativeToWindow:)]
        pub unsafe fn beginModalSessionForWindow_relativeToWindow(
            &self,
            window: Option<&NSWindow>,
            doc_window: Option<&NSWindow>,
        ) -> NSModalSession;

        #[deprecated]
        #[method(application:printFiles:)]
        pub unsafe fn application_printFiles(
            &self,
            sender: Option<&NSApplication>,
            filenames: Option<&NSArray<NSString>>,
        );

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[method(beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:)]
        pub unsafe fn beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo(
            &self,
            sheet: &NSWindow,
            doc_window: &NSWindow,
            modal_delegate: Option<&AnyObject>,
            did_end_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -[NSWindow endSheet:] instead"]
        #[method(endSheet:)]
        pub unsafe fn endSheet(&self, sheet: &NSWindow);

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -[NSWindow endSheet:returnCode:] instead"]
        #[method(endSheet:returnCode:)]
        pub unsafe fn endSheet_returnCode(&self, sheet: &NSWindow, return_code: NSInteger);

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -enumerateWindowsWithOptions:usingBlock: instead"]
        #[method_id(@__retain_semantics Other makeWindowsPerform:inOrder:)]
        pub unsafe fn makeWindowsPerform_inOrder(
            &self,
            selector: Sel,
            flag: bool,
        ) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSGraphicsContext")]
        #[deprecated = "This method always returns nil. If you need access to the current drawing context, use [NSGraphicsContext currentContext] inside of a draw operation."]
        #[method_id(@__retain_semantics Other context)]
        pub unsafe fn context(&self) -> Option<Retained<NSGraphicsContext>>;
    }
);
