//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSFetchRequestResultType(pub NSUInteger);
bitflags::bitflags! {
    impl NSFetchRequestResultType: NSUInteger {
        const NSManagedObjectResultType = 0x00;
        const NSManagedObjectIDResultType = 0x01;
        const NSDictionaryResultType = 0x02;
        const NSCountResultType = 0x04;
    }
}

unsafe impl Encode for NSFetchRequestResultType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFetchRequestResultType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    pub unsafe trait NSFetchRequestResult: NSObjectProtocol {}

    unsafe impl ProtocolType for dyn NSFetchRequestResult {}
);

unsafe impl NSFetchRequestResult for NSNumber {}

unsafe impl NSFetchRequestResult for NSDictionary {}

extern_methods!(
    /// NSFetchedResultSupport
    #[cfg(feature = "NSManagedObject")]
    unsafe impl NSManagedObject {}
);

#[cfg(feature = "NSManagedObject")]
unsafe impl NSFetchRequestResult for NSManagedObject {}

extern_methods!(
    /// NSFetchedResultSupport
    #[cfg(feature = "NSManagedObjectID")]
    unsafe impl NSManagedObjectID {}
);

#[cfg(feature = "NSManagedObjectID")]
unsafe impl NSFetchRequestResult for NSManagedObjectID {}

__inner_extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSPersistentStoreRequest")]
    pub struct NSFetchRequest<ResultType: ?Sized = AnyObject> {
        __superclass: NSPersistentStoreRequest,
        _inner0: PhantomData<*mut ResultType>,
        notunwindsafe: PhantomData<&'static mut ()>,
    }

    #[cfg(feature = "NSPersistentStoreRequest")]
    unsafe impl<ResultType: ?Sized + Message> ClassType for NSFetchRequest<ResultType> {
        #[inherits(NSObject)]
        type Super = NSPersistentStoreRequest;
        type Mutability = InteriorMutable;

        fn as_super(&self) -> &Self::Super {
            &self.__superclass
        }

        fn as_super_mut(&mut self) -> &mut Self::Super {
            &mut self.__superclass
        }
    }
);

#[cfg(feature = "NSPersistentStoreRequest")]
unsafe impl<ResultType: ?Sized + NSCoding> NSCoding for NSFetchRequest<ResultType> {}

#[cfg(feature = "NSPersistentStoreRequest")]
unsafe impl<ResultType: ?Sized + IsIdCloneable> NSCopying for NSFetchRequest<ResultType> {}

#[cfg(feature = "NSPersistentStoreRequest")]
unsafe impl<ResultType: ?Sized> NSObjectProtocol for NSFetchRequest<ResultType> {}

extern_methods!(
    #[cfg(feature = "NSPersistentStoreRequest")]
    unsafe impl<ResultType: Message> NSFetchRequest<ResultType> {
        #[method_id(@__retain_semantics Other fetchRequestWithEntityName:)]
        pub unsafe fn fetchRequestWithEntityName(entity_name: &NSString) -> Retained<Self>;

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics Init initWithEntityName:)]
        pub unsafe fn initWithEntityName(
            this: Allocated<Self>,
            entity_name: &NSString,
        ) -> Retained<Self>;

        #[method_id(@__retain_semantics Other execute:_)]
        pub unsafe fn execute(&self) -> Result<Retained<NSArray<ResultType>>, Retained<NSError>>;

        #[cfg(feature = "NSEntityDescription")]
        #[method_id(@__retain_semantics Other entity)]
        pub unsafe fn entity(&self) -> Option<Retained<NSEntityDescription>>;

        #[cfg(feature = "NSEntityDescription")]
        #[method(setEntity:)]
        pub unsafe fn setEntity(&self, entity: Option<&NSEntityDescription>);

        #[method_id(@__retain_semantics Other entityName)]
        pub unsafe fn entityName(&self) -> Option<Retained<NSString>>;

        #[method_id(@__retain_semantics Other predicate)]
        pub unsafe fn predicate(&self) -> Option<Retained<NSPredicate>>;

        #[method(setPredicate:)]
        pub unsafe fn setPredicate(&self, predicate: Option<&NSPredicate>);

        #[method_id(@__retain_semantics Other sortDescriptors)]
        pub unsafe fn sortDescriptors(&self) -> Option<Retained<NSArray<NSSortDescriptor>>>;

        #[method(setSortDescriptors:)]
        pub unsafe fn setSortDescriptors(
            &self,
            sort_descriptors: Option<&NSArray<NSSortDescriptor>>,
        );

        #[method(fetchLimit)]
        pub unsafe fn fetchLimit(&self) -> NSUInteger;

        #[method(setFetchLimit:)]
        pub unsafe fn setFetchLimit(&self, fetch_limit: NSUInteger);

        #[cfg(feature = "NSPersistentStore")]
        #[method_id(@__retain_semantics Other affectedStores)]
        pub unsafe fn affectedStores(&self) -> Option<Retained<NSArray<NSPersistentStore>>>;

        #[cfg(feature = "NSPersistentStore")]
        #[method(setAffectedStores:)]
        pub unsafe fn setAffectedStores(
            &self,
            affected_stores: Option<&NSArray<NSPersistentStore>>,
        );

        #[method(resultType)]
        pub unsafe fn resultType(&self) -> NSFetchRequestResultType;

        #[method(setResultType:)]
        pub unsafe fn setResultType(&self, result_type: NSFetchRequestResultType);

        #[method(includesSubentities)]
        pub unsafe fn includesSubentities(&self) -> bool;

        #[method(setIncludesSubentities:)]
        pub unsafe fn setIncludesSubentities(&self, includes_subentities: bool);

        #[method(includesPropertyValues)]
        pub unsafe fn includesPropertyValues(&self) -> bool;

        #[method(setIncludesPropertyValues:)]
        pub unsafe fn setIncludesPropertyValues(&self, includes_property_values: bool);

        #[method(returnsObjectsAsFaults)]
        pub unsafe fn returnsObjectsAsFaults(&self) -> bool;

        #[method(setReturnsObjectsAsFaults:)]
        pub unsafe fn setReturnsObjectsAsFaults(&self, returns_objects_as_faults: bool);

        #[method_id(@__retain_semantics Other relationshipKeyPathsForPrefetching)]
        pub unsafe fn relationshipKeyPathsForPrefetching(
            &self,
        ) -> Option<Retained<NSArray<NSString>>>;

        #[method(setRelationshipKeyPathsForPrefetching:)]
        pub unsafe fn setRelationshipKeyPathsForPrefetching(
            &self,
            relationship_key_paths_for_prefetching: Option<&NSArray<NSString>>,
        );

        #[method(includesPendingChanges)]
        pub unsafe fn includesPendingChanges(&self) -> bool;

        #[method(setIncludesPendingChanges:)]
        pub unsafe fn setIncludesPendingChanges(&self, includes_pending_changes: bool);

        #[method(returnsDistinctResults)]
        pub unsafe fn returnsDistinctResults(&self) -> bool;

        #[method(setReturnsDistinctResults:)]
        pub unsafe fn setReturnsDistinctResults(&self, returns_distinct_results: bool);

        #[method_id(@__retain_semantics Other propertiesToFetch)]
        pub unsafe fn propertiesToFetch(&self) -> Option<Retained<NSArray>>;

        #[method(setPropertiesToFetch:)]
        pub unsafe fn setPropertiesToFetch(&self, properties_to_fetch: Option<&NSArray>);

        #[method(fetchOffset)]
        pub unsafe fn fetchOffset(&self) -> NSUInteger;

        #[method(setFetchOffset:)]
        pub unsafe fn setFetchOffset(&self, fetch_offset: NSUInteger);

        #[method(fetchBatchSize)]
        pub unsafe fn fetchBatchSize(&self) -> NSUInteger;

        #[method(setFetchBatchSize:)]
        pub unsafe fn setFetchBatchSize(&self, fetch_batch_size: NSUInteger);

        #[method(shouldRefreshRefetchedObjects)]
        pub unsafe fn shouldRefreshRefetchedObjects(&self) -> bool;

        #[method(setShouldRefreshRefetchedObjects:)]
        pub unsafe fn setShouldRefreshRefetchedObjects(
            &self,
            should_refresh_refetched_objects: bool,
        );

        #[method_id(@__retain_semantics Other propertiesToGroupBy)]
        pub unsafe fn propertiesToGroupBy(&self) -> Option<Retained<NSArray>>;

        #[method(setPropertiesToGroupBy:)]
        pub unsafe fn setPropertiesToGroupBy(&self, properties_to_group_by: Option<&NSArray>);

        #[method_id(@__retain_semantics Other havingPredicate)]
        pub unsafe fn havingPredicate(&self) -> Option<Retained<NSPredicate>>;

        #[method(setHavingPredicate:)]
        pub unsafe fn setHavingPredicate(&self, having_predicate: Option<&NSPredicate>);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(feature = "NSPersistentStoreRequest")]
    unsafe impl<ResultType: Message> NSFetchRequest<ResultType> {
        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

#[cfg(all(feature = "NSPersistentStoreResult", feature = "block2"))]
pub type NSPersistentStoreAsynchronousFetchResultCompletionBlock =
    *mut block2::Block<dyn Fn(NonNull<NSAsynchronousFetchResult>)>;

__inner_extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSPersistentStoreRequest")]
    pub struct NSAsynchronousFetchRequest<ResultType: ?Sized = AnyObject> {
        __superclass: NSPersistentStoreRequest,
        _inner0: PhantomData<*mut ResultType>,
        notunwindsafe: PhantomData<&'static mut ()>,
    }

    #[cfg(feature = "NSPersistentStoreRequest")]
    unsafe impl<ResultType: ?Sized + Message> ClassType for NSAsynchronousFetchRequest<ResultType> {
        #[inherits(NSObject)]
        type Super = NSPersistentStoreRequest;
        type Mutability = InteriorMutable;

        fn as_super(&self) -> &Self::Super {
            &self.__superclass
        }

        fn as_super_mut(&mut self) -> &mut Self::Super {
            &mut self.__superclass
        }
    }
);

#[cfg(feature = "NSPersistentStoreRequest")]
unsafe impl<ResultType: ?Sized + IsIdCloneable> NSCopying
    for NSAsynchronousFetchRequest<ResultType>
{
}

#[cfg(feature = "NSPersistentStoreRequest")]
unsafe impl<ResultType: ?Sized> NSObjectProtocol for NSAsynchronousFetchRequest<ResultType> {}

extern_methods!(
    #[cfg(feature = "NSPersistentStoreRequest")]
    unsafe impl<ResultType: Message> NSAsynchronousFetchRequest<ResultType> {
        #[method_id(@__retain_semantics Other fetchRequest)]
        pub unsafe fn fetchRequest(&self) -> Retained<NSFetchRequest<ResultType>>;

        #[cfg(all(feature = "NSPersistentStoreResult", feature = "block2"))]
        #[method(completionBlock)]
        pub unsafe fn completionBlock(
            &self,
        ) -> NSPersistentStoreAsynchronousFetchResultCompletionBlock;

        #[method(estimatedResultCount)]
        pub unsafe fn estimatedResultCount(&self) -> NSInteger;

        #[method(setEstimatedResultCount:)]
        pub unsafe fn setEstimatedResultCount(&self, estimated_result_count: NSInteger);

        #[cfg(all(feature = "NSPersistentStoreResult", feature = "block2"))]
        #[method_id(@__retain_semantics Init initWithFetchRequest:completionBlock:)]
        pub unsafe fn initWithFetchRequest_completionBlock(
            this: Allocated<Self>,
            request: &NSFetchRequest<ResultType>,
            blk: Option<&block2::Block<dyn Fn(NonNull<NSAsynchronousFetchResult<ResultType>>)>>,
        ) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(feature = "NSPersistentStoreRequest")]
    unsafe impl<ResultType: Message> NSAsynchronousFetchRequest<ResultType> {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
